## Java

### `==` 和 `equals` 的区别

​		`==` 是运算符, `equals()` 是 `Object` 类中提供的一个用来对比的方法, 他们两个都可以用来判断两个值是否相等, 用 `==` 来对比基本数据类型的话, 对比的是基本数据类型的值, 用 `==` 对比对象的话, 对比的就是对象的引用地址

​		一般基础数据类型对比可以用 `==` , 对象的对比用 `equals()` , 但是 `Object` 类中的 `equals()` 方法内部就是 `==` , 所以对象对比的话要重写 `equals()` 和 `hashcode()` 方法



### `Bean` 的生命周期?

scan -> parse -> cache -> ?

第一步是扫描到这个类, 然后解析类的信息(className、scope ...)成 `BeanDefinition` 对象



### `IOC` 的理解

`IOC` 是 `Spring` 的核心, 一个应用程序其实就是许多个对象协同工作, `IOC` 的作用就是借助于 `IOC容器` 来实现具有依赖关系的对象之间的解耦, 就是在 A对象中, 需要用的 B对象的时候, 创建 B对象的过程从手动创建变成 `IOC容器` 帮我们创建并且注入到 A对象中 用到B对象的地方, 就是在系统运行中, 动态的向某个对象提供这个对象依赖的其他对象

![image-20210819142020408](C:\Users\dangjian\AppData\Roaming\Typora\typora-user-images\image-20210819142020408.png)



### `DI` 的理解

通过反射形式动态的注入对象的过程



### `AOP` 的理解

在不影响原有代码功能的基础上对代码进行的功能上的增强, 把多个业务共有的与业务无关的逻辑代码抽离出来与业务代码隔离的过程, 常见的: 日志记录, 异常处理, 身份校验





### `Spring` 的理解

`Spring` 是一个轻量级的框架, 同时也是一个容器, 而且还是一个生态

![image-20210819162002775](C:\Users\dangjian\AppData\Roaming\Typora\typora-user-images\image-20210819162002775.png)



### `ArrayList` 和 `LinkedList` 的区别

`ArrayList` 和 `LinkedList` 都实现了 `List` 接口, 不同的是 `ArrayList` 底层是用数组来存储数据, `LinkedList` 的底层是链表, `ArrayList` 的访问速度更快, `LinkedList` 增删操作更快



### 抽象类和接口的区别

- 抽象类可以定义构造器, 可以被实例化, 接口不可以
- 抽象类可以定义具体方法, 接口只能定义抽象方法
- 抽象类可以定义静态方法, 接口不可以
- 抽象类可以定义成员变量, 接口只能定义常量
- 抽象类的抽象方法可以被除了 `private` 之外的任何修饰符修饰, 接口中的抽象方法只能是 `public` 修饰
- 抽象类只能单继承, 接口继承接口可以多继承, 接口被实现时也可以多实现

抽象类是对事物的抽象, 接口是对行为的抽象

抽象类定义的是继承体系的共性功能, 接口定义的是继承体系的扩展功能



### `Spring` 中 `Bean` 的作用域

| 作用域           | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| `singleton`      | 在 `Spring Ioc` 容器仅存在一个 `Bean` 实例，`Bean` 以单例方式存在，默认值 |
| `prototype`      | 每次从容器中调用Bean时，都返回一个新的实例，即每次调用 `getBean()` 时，相当于执行 `newXxxBean()` |
| `request`        | 每次 `HTTP` 请求都会创建一个新的 `Bean`                      |
| `session`        | 同一个 `HTTP Session` 共享一个 `Bean` ，不同 `Session` 使用不同的 `Bean` |
| `global-session` |                                                              |



### `Bean` 的生命周期





### `Spring` 中单例对象的线程安全问题

可以用 `ThreadLocal` 对有状态变量进行管理, `ThreadLocal` 会为每个线程创建一个独立的副本



### `Restful` 风格

是一种接口设计风格, 可以让代码更简洁, 使用 `动词 + 宾语 = 请求` 的形式来表示

**GET**/zoos列出所有动物园

**POST**/zoos新建一个动物园

**GET**/zoos/:id获取某个指定动物园的信息

**PUT**/zoos/:id更新某个指定动物园的全部信息

**PATCH**/zoos/:id更新某个指定动物园的部分信息

**DELETE**/zoos/:id删除某个动物园

**GET**/zoos/:id/animals列出某个指定动物园的所有动物

**DELETE**/zoos/:id/animals/:id删除某个指定动物园的指定动物



### `HashMap` 的底层



### 接口幂等问题

接口幂等就是同一个接口发起多次同样的请求, 必须保证只执行一次

如何解决?

可以使用 `AOP` 来保证, 将 `Token` 和 `请求url` 存入缓存, 只有当缓存中不存在相同数据时, 才会执行, 执行完后删除刚刚存入的数据

### `SpringBoot` 的理解



### `@SpringBootApplicaton` 的运行机制

@SpringBootApplication 是一个复合注解, 注解内部有三个主要的注解

- @SpringBootConfiguration 相当于 Spring 中的 @Configuration , 用来标注类为配置类
- @EnableAutoConfiguration

**TODO**



### 类的加载过程



### `Cookie` 和 `Session`

`cookie` 数据存放在客户端, 容量不超过 `4K` , 只能保存字符串, 

`session` 数据存放在服务器端, 容量没有限制, 可以保存任何类型的数据



#### `Cookie` 被浏览器禁用的问题





### `Aop` 怎么做全局的异常处理



### 自定义注解

自定义注解会自动继承 `Annotation` 接口, 必须指定注解何时生效、注解目标是什么

### `IO`







## `VUE2`



## `Mysql`

### 事务(Mysql)

>  `ACID`

**原子性**

最小不可分割, 把一个事务视作一个整体, 一个整体不会有两种状态, 就是 **要么都成功, 要么都失败**

**一致性**

事务前后的数据完整性要保持一致

**隔离性**

多个事务同时进行的时候, 事务与事务之间要隔离开, 不能产生干扰

**持久性**

事务一旦提交就不可逆转



> 隔离性可能会导致的一些问题如下

**脏读**

一个事务读取了其他事务未提交的数据

**不可重复读**

在一个事务内多次读取同一处数据的结果不同 *update*

**虚读(幻读)**

在一个事务内读取到了其他事务插入的数据 *add*



### 索引

>  **索引（Index）是帮助MySQL高效获取数据的<u>数据结构</u>。**
>
> 默认类型是 B+Tree

#### 分类

- 主键索引 `primary key`
  - 唯一标识, 不可重复, 并且最多只能有一列作为主键索引
- 唯一索引 `unique key`
  - 避免重复的列出现, 可以重复, 可以有多个列作为唯一索引
- 常规索引 `key/index`
  - 默认的, 可以用 `key/index` 来设置
- 全文索引 `FullText`
  - 快速定位数据

#### 原则

- 索引不是越多越好
- 不要对频繁改变的数据加索引
- 小数据量不要加索引
- 索引加在常用查询的字段上

## `MyBatis`

> 文档地址: https://mybatis.org/mybatis-3/zh/sqlmap-xml.html

### 接口是怎么和xml中的sql进行绑定的

通过 `mapper` 标签的 `namespace` 属性与接口文件的**全限定类名**进行绑定, 然后通过 CRUD 标签的 `id` 与 接口中的方法名进行绑定



### 如何在插入/更新数据后拿到该数据的id

把 `insert/update` 标签的 `useGeneratedKeys` 属性设置为 `true`



### #{} 和 ${} 的区别

#{} 是预处理方式, `Mybatis` 会把 #{} 替换成 ? , 然后调用 `PreparedStatement` 中的 `set` 方法来赋值, 可以有效防止 Sql 注入

${} 是字符串替换



## Redis

### 什么是 Redis

**Re**mote **Di**ctionary **S**erver, 远程字典服务, 是一个开源的基于内存的可持久化的 NoSql 数据库

#### Redis 可以做什么

- 内存存储
- 持久化
- 用于高速缓存

#### Redis 的特性

- 多种数据结构
- 持久化
- 事务
- 集群

#### 基础知识

Redis 默认有 16 个数据库

##### 设置 KV

```bush
set name zhangsan
```

##### 获取 V

```bush
get name
```

##### 切换数据库

> `select index`
>
> Redis 默认有16个数据库, index表示哪个数据库 *0 - 15*

```bush
select 1
```

##### 数据库数据量

```bush
dbsize
```

##### 查看全部 K 列表

> `keys pattern`

```buysh
keys *
```

##### 清空当前库

```bush
flushdb
```

##### 清空所有库

```bush
flushAll
```

##### 查看 K 是否存在

```bush
exists k
```

##### 移除当前库中的 K

```bush
move K 1
```

##### 设置过期时间(秒)

> 过期后会被删除

```bush
expire K 10
```

##### 查看剩余有效时间(秒)

```bush
ttl K
```

##### 查看 K 类型

```bush
type K
```







#### Redis 单线程为什么这么快

Redis 是将所有的数据放到内存中的, 对于内存来说, 没有上下文切换, 效率就是最高的



#### String

> String 除了是字符串, 还可以是数字

##### 追加字符串

> 不会影响过期时间
>
> 如果 K 不存在, 相当于 `set K str`

```bush
append K str
```

##### 获取字符串长度

```bush
strlen K
```

##### 自增

> 步长设置
>
> incrby K 10

```bush
incr K
```

##### 自减

> 步长设置
>
> decrby K 10

```bush
decr K
```

##### 获取字符串的指定范围

```bush
getrange K 3 -1
```

##### 替换指定位置开始的字符串

```bush
setrange K 3 xxx
```

##### 以原子性级别设置 K V 并且指定过期时间

```bush
setex K 60 xxxxxxxxxxxxxxxx
```

##### 如果不存在则设置

> if not exists

```bush
setnx K V
```

##### 批量设置 K V

```bush
mset k1 v1 k2 v2
```

##### 批量获取V

```bush
mget k1 k2
```

##### 以原子性级别批量设置 K V

> 只要有一个存在, 那么就全部失败

```bush
msetnx k1 v1 k2 v2
```

##### 先 get 再 set

```bush
getset K V
```



#### List

> 在 Redis 中, 可以把 List 当作队列操作
>
> **所有 List 命令, 都是以 L 开头**

##### 将 + 个值插入到 List 头部

> 挨个插到头部

```bush
lpush l 1 2 3
```

##### 将 + 个值插入到 List 尾部

```bush
rpush l 1 2 3
```

##### 移除头部

```bush
lpop l
```

##### 移除尾部

```bush
rpop l
```

##### 根据下标获取值

```bush
lindex l 2
```

##### 获取 List 中的值

```bash
lrange l 0 -1
```

##### 获取 List 长度

```bush
llen l
```

##### 移除指定的值

> 移除 3 个 xxx

```bush
lrem l 3 xxx
```

##### 只保留指定下标区间的值

```bush
ltrim l 2 4
```

##### 将尾部的值移动到指定的List头部

```bush
rpoplpush list1 list2
```

##### 在指定下标位置设置值

> list 必须存在

```bush
lset l 0 xxx
```



